<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        font: 10px sans-serif;
        shape-rendering: crispEdges;
        position:absolute;
        top:5vh;
    }
    
    .barChart {
        position:relative;
        left:100px;
        bottom: 0;} 
   
    .key path , .key line{
    fill:none;
    stroke:#000;}
    
    
    
</style>

<body>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script>
        var dateFormat = d3.time.format('%Y-%m-%d');
        var dataSet = [];
        var Sweather = d3.csv('data/seoul_weather_year.csv', function (err, weather) {
            weather.forEach(function (row) {
                row['aver'] = +row['aver'];
                row['date'] = dateFormat.parse(row['date']); // d3 format으로 검색하면 나옵니다.

            })

            dataSet = weather;
            redraw();
        });

//        
//        var makeDay = dataSet.map(function(d){
//            return {
//                mkd : dataSet[aver] 
//            };
//        });
//        
//        console.log(makeDay.mkd);



        //--- Layout--------------------------------------------

        var redraw = function () {


            MARGIN = {

                TOP: 500,
                LEFT: 100,
                RIGHT: 100,
                BOTTOM: 100

            };

            //--- chart Size ---------------------------------------------

            var Width = 1000;
            var Height = 80;

//            var formatPercent = d3.format(".0%");
//            var formatNumber = d3.format(".0f");

            //--- Scale --------------------------------------------


            var xScale = d3.time.scale()
                .domain([
                new Date(dataSet[0].date),
                d3.time.month.offset(new Date(dataSet.length.date), 1)
            ]) //여기서 1은 offset 안에 있는것이므로 이것을 검색하면 알 수 있다.
                //day.offset이므로 new Date()에서는 날자를 ,1은 간격을 의미한다.
                .rangeRound([0, Width - MARGIN.LEFT]);


            var yScale = d3.time.scale()
                .domain([new Date(dataSet[0].date),
                     d3.time.year.offset(new Date(dataSet.length.date), 0)]) //여기서 0은 시작점점
                .rangeRound([Height - MARGIN.TOP - MARGIN.BOTTOM, 0]);


            var colorScale = d3.scale.quantize()
                .domain([d3.max(dataSet, function (d) {
                    return d.aver;
                }), d3.min(dataSet, function (d) {
                    return d.aver;
                })])//min과 max는 이렇게 쓰는거다.
                .range(["red",'rgb(215, 48, 39)', 'rgb(244, 109, 67)', 'rgb(253, 174, 97)', 'rgb(254, 224, 139)', 'rgb(255, 255, 191)', 'rgb(217, 239, 139)',
               'rgb(166, 217, 106)', 'rgb(102, 189, 99)', 'rgb(26, 152, 80)', 'rgb(0, 104, 55)']);

console.log(dataSet);

        var barX = d3.scale.linear()
            .domain([d3.max(dataSet, function (d) {
                    return d.aver;
                }), d3.min(dataSet, function (d) {
                    return d.aver;
                })])
            .range([0,150]);

        var barXaxis = d3.svg.axis()
            .scale(barX)
            .orient("bottom");
//            .tickSize(14)
//            .tickValues(colorScale.domain());
//            .tickFormat(function(d) { return d; });
        
   
           
    //if 5이면 앞에거 else면 뒤에거를 해주는 단순한 식.

        var barSvg = d3.select("body")
            .append("svg")
            .attr("width",400)
            .attr("height", 30)
            .attr('class', "barChart");
            

        var G= barSvg.append("g")
            .attr("class", "key")
            .attr("transform", "translate(" +6 + ",0)")
            .call(barXaxis);
            
//invertExtent 역함수와 같고, 컬러를 숫자로 매치해서 반대로 수치의 범위를 알려주는 식 
        G.selectAll("rect.scale-bar")
              .data(colorScale.range().map(function(color) {
              var d = colorScale.invertExtent(color);
              if (d[0] == null) d[0] = barX.domain()[0];
              if (d[1] == null) d[1] = barX.domain()[1];
              return d;
            }))
            .enter()
            .append("rect")
            .attr('class', 'scale-bar')
            .attr("height", 8)
            .attr("x", function(d) { return barX(d[0]); })
            .attr("width", function(d) { return barX(d[1]) - barX(d[0]); })
            .style("fill", function(d) { return colorScale(d[0]); });

        G.call(barXaxis)
            .append("text")
            .attr("class", "caption")
            .attr("y", -6)
            .text("Range of color");
            
            
            
//makeGraph            
            
            var cellSize = Height/12;
             // cell size


            var svg = d3.select("body")
                .selectAll("svg.year")
                .data(d3.range(2010, 2016))
                .enter()
                .append("svg")
                .attr('class', 'year')
                .attr("width", Width)
                .attr("height", Height)
                .style("margin-bottom",10)
                .attr("transform", "translate(" + MARGIN.LEFT + "," + MARGIN.TOP + MARGIN.BOTTOM +"  )")
                .append("g")
                .attr("transform", "translate(" + MARGIN.LEFT + ",   0)");
                

            svg.append("text")
                .attr("transform", "translate(-30," + cellSize * 6 + ")")
                .style("text-anchor", "middle")
                .text(function (d) {
                    return d;
                });

            var rect = svg.selectAll(".day")
                .data(function (d,i) {
                    return d3.time.days(new Date(d, 0, 1), new Date(d+1, 0, 1),1);
                })
                .enter()
                .append("rect")
                .attr("class", "day")
                .attr("width", cellSize)
                .attr("height", cellSize)
                .attr("x", function (d) {
                    return d.getDate(d) * cellSize;
                })
                .attr("y", function (d) {
                    return d.getMonth() * cellSize;
                                        
                })
                .datum(dateFormat);
            
       
            
             rect.style("fill", function (d,i) {
//                 console.log((+d.substr(0, 4) - 2010));
                    console.log(
                       (+d.substr(0, 4) - 2010)* 365 + i);
                    return colorScale(dataSet[ (+d.substr(0, 4) - 2010) * 365 + i].aver);
                   
                });


             rect.append("title")
                  .text(function (d,i) {
                    return d+", "+dataSet[i].aver+"º" ;
                });
        
            
            

            //            var imdata = d3.csv("data/seoul_weather_year.csv", function (error, csv) {
            //                if (error) throw error;
            //                var data = d3.nest().key(function (d) {
            //                        return d.date;
            //
            //                    })
            //                    .rollup(function (d) {
            //                        return d.aver
            //
            //                    })
            //                    .map(csv);
            //
            //
            //
            //                rect.filter(function (d) {
            //                        return d in data;
            //                    })
            //                    .attr("class", function (d) {
            //                        return "day " + color(data[d.aver]);
            //
            //                    })
            //
            //            });



        };
    </script>